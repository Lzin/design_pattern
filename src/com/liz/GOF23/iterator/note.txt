迭代器模式:
1.需求:
   编写程序展示一个学校院系结构: 需求是这样的，要在一个页面中展示出学校的院系组成，一个学校中有多个学院，一个学院中有多个系。如何做到遍历他们。
  （组合模式的例子）
2.解决方案: 采用迭代器模式 => 使用统一的迭代器进行遍历

3.迭代器模式简单介绍:
    1.迭代器模式（Iterator Pattern）是常用的设计模式，属于行为型模式
    2.如果我们的集合元素是用不同的方式实现，有数组，还有java的集合类或者其他方式，当客户端遍历这些集合元素的时候就要使用多种遍历方式，而且还会暴露元素的内部结构，所以用迭代器模式解决
    3.迭代器模式，提供了一种遍历集合元素的统一接口，用一致的方式遍历集合元素，不需要知道集合元素的底层表示，即:不暴露内部的结构
    4.遍历方式和存放方式进行分离
    5.角色:
        抽象聚合（Aggregate）角色：定义存储、添加、删除聚合对象以及创建迭代器对象的接口。
        具体聚合（ConcreteAggregate）角色：实现抽象聚合类，返回一个具体迭代器的实例。
        抽象迭代器（Iterator）角色：定义访问和遍历聚合元素的接口，通常包含 hasNext()、first()、next() 等方法。
        具体迭代器（Concretelterator）角色：实现抽象迭代器接口中所定义的方法，完成对聚合对象的遍历，记录遍历的当前位置。

4.ArrayList
    List: 聚合接口 =>内部有iterator方法，返回迭代器对象
    ArrayList: 具体的List类，内部维护了一个elementData数组（obj） =>存放具体数据

    Iterator: 系统提供的迭代器接口
    Itr:具体的实现类（是ArrayList的内部类，具体实现迭代器Iterator的类，作为ArrayList的内部类）

    迭代器模式解决了不同迭代器的统一遍历问题

5.迭代器模式的细节:
    优点:
        1.提供了一个统一的方法遍历对象，客户不需要再考虑聚合的类型，使用一种方法就可以遍历对象了
        2.隐藏了聚合的内部结构，客户端要遍历聚合的时候只能取到迭代器，而不知道如何聚合
        3.提供了一种设计思想，一个类只有一个引起变化的原因(单一责任原则)，在聚合类中，我们把迭代器分开，就是要把管理对象集合和遍历对象集合的责任进行分开。如果集合改变了，只会影响到对象，如果遍历方式改变了，只会影响迭代器
        4.当展示一组相似对象的时候，或者遍历一组相同对象的时候，适合使用迭代器模式
    缺点:
        1.每个聚合对象都需要一个迭代器，会生成多个迭代器不好管理类







