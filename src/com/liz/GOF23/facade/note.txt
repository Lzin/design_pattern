外观模式:
    1.需求: 组建一个家庭影院
        组成部分: DVD遥控器，投影仪，自动屏幕，环绕立体声，爆米花机
        过程:
            1.直接用遥控器控制各项设备开关
            2.开爆米花机 -> 放下屏幕 -> 开投影仪 -> 开音响 -> 开DVD,选择音乐 -> 调暗灯光 -> 播放电影 -> 观影结束，关闭所有设备

    2.解决方案:
        1.传统方式: 构建客户端，调用各个设备的一系列方法（图中的ClientTest 直接依赖于各个设备）
        2.分析
            * clientTest的方法中，创建各个子系统的对象，直接调用子系统的相关方法，会造成调用过程的混乱
            * 不利于维护操作
        3.解决思路: 使用外观模式

    3.外观模式的基本介绍:
        1.外观模式(Facade),也称为“过程模式”,外观模式为子系统提供一个一致的界面，此界面定义了一系列子系统的引用。便于组合子系统的逻辑
        2.定义规范（界面类），用来屏蔽内部子系统的细节，使得调用端只需要和这个(接口 or 类)发送调用，而无需关系子系统的内部细节(外观模式)
        3.角色:
            1.外观类(Facade) 为调用端提供统一的调用接口，外观类知道哪些子系统负责处理请求，从而将调用端的请求代理给适当的子系统对象
            2.调用者(Client) 外观接口的调用者
            3.子系统（Sub System） :模块或者是子系统，处理Facade对象指派的任务(功能的实际提供者)

        4.外观模式可以理解为在一个类中（这里称之为界面类）使用其他的功能类，然后用户如果想使用功能类，无需调用功能类的方法，而是调用界面类。
          就像点菜的时候点套餐，电脑安装软件的时候点击自动安装等。

    4.外观模式的注意点和细节:
        1.外观模式对外屏蔽了子系统的细节，因此外观模式降低了客户端对子系统使用的复杂性
        2.外观模式降低了客户端和子系统的耦合性，便于维护和扩展
        3.当系统需要进行分层设计的时候，可以考虑外观模式
        4.不要过多或者不合理使用外观模式，要在使用外观模式或者直接调用模块之间进行取舍（要让系统有层次，利于维护，如果子系统比较简单，就无须使用外观模式）
        5.当直接调用子系统是复杂的时候，可以使用外观模式先完成逻辑，
    优点：
    1.简化调用流程，客户端不需要知道子系统的实现，提高了安全性，符合“迪米特原则”。
    2.提高灵活性，降低用户类和子系统类的耦合度，实现了松耦合。
    3.更好的划分访问层次。

    缺点：
    如果新增子系统，需要修改外观类，违背了“开闭原则”。



