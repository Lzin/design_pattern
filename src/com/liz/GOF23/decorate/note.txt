装饰者模式（包装模式）:
    1.实例: 咖啡订单项目
        1.咖啡种类/单品咖啡:Espresso(意大利浓咖啡),ShortBlack,LongBlack(美式咖啡),Decaf(无因咖啡)
        2.调料: Milk,Soy(豆浆),Chocolate(巧克力)
        3.要求在扩展新的咖啡种类时，具有良好的扩展性，改动方便，维护方便
        4.计算不同种类的咖啡的费用:
            客户可以单点咖啡
            客户也可以点咖啡+调料组合
            (调料和单品两个维度.. 桥接警告)

    2.方案1:
        1.Drink是一个抽象类，表示饮料
        2.des就是对咖啡的描述
        3.cost()就是计算费用，在Drink中作为一个抽象方法
        4.Decaf就是单品咖啡，继承Drink并且实现cost
        5.Espresso+Milk 就是单品咖啡+调料，这种组合很多
        6.分析: 这样设计会出现很多的类（类爆炸）

    3.方案2:
        1.将调料内置到Drink抽象类中，不会造成类的数量过多
        2.再用各种单品咖啡继承Drink，所以每一种单品咖啡中拥有了所有的调料（增加相应的hasXxx方法）
        3.分析:
            1.这种方法可以控制类的数量，不至于造成过多的类（不会引起类爆炸）
            2.在增加或者删除调料种类时，代码的维护量过大
            3.考虑到用户可以添加多份调料时，可以将hasXxx返回一个int型即可
            4.考虑使用装饰者模式

    4.装饰者模式:

        特点: 动态地将新功能附加到对象上，在对象扩展方便比继承更好，装饰者模式也体现了ocp原则
        介绍: 装饰者模式就像给游戏打各种补丁一样...

        角色:
            1.主体(被装饰者）: Component（比如前面的Drink）
            2.具体的主体: ConcreteComponent(比如前面的各种单体咖啡实例)
            3.装饰者: Decorator() 【在装饰者中关联了被装饰者的抽象类】
            4.具体的装饰者: DecoratorImpl

        注:装饰者模式可以做到在不修改任何底层代码的情况下，给对象增加新的方法，拓展类的功能。

        优点: 装饰者模式比继承灵活性，在不改变原有对象的情况下给对象扩展功能，符合开闭原则。
        缺点: 1. 装饰模式会导致设计出大量的ConcreteDecorator类，增加系统的复杂性。
              2.对于多次装饰的对象，一旦出现错误，排错繁琐；







