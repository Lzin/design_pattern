享元模式:
1.需求:不同的用户以不同的方案展示内容
（客户A: 新闻发布 客户B:博客发布 客户C:微信公众号发布）

2.解决方案
    1.将内容直接复制粘贴一份，然后根据客户的不同需求，进行定制修改发布功能
    2.分析
        1.相似的实例对象出现多份，造成资源的冗余和浪费
        2.多份实例进行维护和扩展比较麻烦
        3.解决方法: 享元模式

3.享元模式介绍
    1.享元模式（Flyweight pattern）也称为蝇量模式:运用共享技术有效复用细粒度对象（避免重复创建对象）
    2.享元模式可以解决 重复对象的内存浪费 问题（假设系统中有大量相似对象，不需要总是创建新对象，可以从建立缓冲池中拿取。这样可以降低系统内存，提高效率）
    3.享元模式是池技术的重要实现方式，String常量池，数据库连接池以及缓冲池都是该技术的应用
    4.角色:
        1.FlyWeight:抽象的享元角色，它是产品的抽象类，同时定义出对象的外部状态和内部状态的方法或者实现
            外部状态: 对象得以依赖的标记，随环境改变而改变，不可共享       （以下棋为例，棋子的位置）
            内部状态: 对象共享的信息，存储在享元对象内部，不随环境改变而改变（以下棋为例，棋子的颜色）

        2.ConcreteFlyWeight: 具体的享元角色,是具体的产品类。实现抽象角色定义的相关业务
        3.UnSharedConcreteFlyWeight:不可共享的角色（一般不会出现在享元工厂中）
        4.FlyweightFactory:享元工厂类, 用于构建一个池容器（集合），同时提供从池中获取对象的相关方法


4.享元模式总结
    1.享元模式:"享"表示共享，"元"表示对象
    2.当系统中有大量对象，这些对象消耗大量内存，但是对象的状态大部分可以外部化时，可以考虑享元模式
    3.如果在内存中存在对象，可以直接返回，如果内存中不存在该对象，可以采用HashMap HashTable进行存储（pool内部的逻辑,使用唯一标识码进行判断 UUID）
    4.!!!在享元模式下，可以避免重复创建相同或者相似的对象，这样可以减少内存和提高程序的效率。
    5.享元模式提高了系统的复杂度，需要分离出 "内部状态"和"外部状态"，而外部状态需要有着固化特性，不应该随着内部状态的改变而改变(一般内部状态在工厂类中，外部状态在工厂外)
    6.享元模式的经典场景: String常量池，数据库连接池等





